# FAST算法原理

# 原理
# 前面介绍过的几个特征检测器，效果都很好，特别是SIFT和SURF算法，但是从实时处理的角度来看，效率还是太低了
# FAST（Feature from accelerated segment test）是一种用于角点检测的算法
# 该算法原理是取图像中检测点，以该点为圆心的周围邻域内像素点判断检测点是否为角点
# 通俗的讲就是若一个像素周围有一定数量的像素与该点像素值不同，则认为其为角点

# 基本流程
# 1.在图像中选取一个像素点p，来判断它是不是关键点，Ip等于像素点p的灰度值
# 2.以r为直径画圆，覆盖p点周围M个像素，通常情况下r=3，则M=16
# 3.设置一个阈值t，若果在这16个像素中存在n个连续零点的灰度值都高于Ip+t，或者都低于Ip-t，那么像素点p就被认为是一个角点，n一般取值为12
# 4.由于在特征检测中是需要对图像中所有的像素点进行检测，然而图像中大多数点都不是特征点
#   如果对每个像素点都进行上述的检测过程，那显然会浪费许多时间，因此采用一种进行非特征点判别的方法：
#   首先对每个候选点的周围每个90度的点（像素点正上方边缘、正下方边缘、正左方边缘、正右方边缘，先测试上下，若符合要求再测左右）
#   若p为角点，那么这四个点中至少有3个符合阈值要求，否则直接剔除
#   对保留下来的点再继续进行测试

# 缺点
#   获得的候选点比较多
#   特征点的选取不是最优的，它的效果取决于要解决的问题和焦点的分布情况
#   进行非特征判别时大量的点被丢弃
#   检测到的很多特征点是相邻的
# 前三个问题可以通过机器学习的方法解决，最后一个问题可以使用非最大值抑制的方法解决

# 机器学习的角点检测器
# 1.选择一组图片（最好是跟最后应用相关的图片）
# 2.使用FAST算法找出每幅图像的特征点，对图像中的每一个特征点，将其周围的16个像素存储构成一个向量P
# 3.每一个像素点的16像素点都属于下列三类的一种
#   Sp→x=d, Ip→x≤Ip-t  (darker)
#       =s, Ip-t<Ip→x<Ip+t  (similar)
#       =b, Ip+t≤Ip→x  (brighter)
# 4.根据这些像素点的分类，特征分量P也被分为3个子集：Pd，Ps，Pb
# 5.定义一个新的布尔变量Kp，如果p是角点就设为True，不是就设置为False
# 6.利用特征值向量p，目标值是$K_p$，训练ID3树（决策树分类器）
# 7.将构建好的决策树运用于其他图像的快速检测

# 非极大值抑制
# 在筛选出来的角点中有很多是紧挨在一起的，需要通过非极大值抑制来消除这种影响
# 为所有的候选角点都确定一个打分函数V，V的值可以这样计算：先分别计算Ip与圆上16个点的像素值插值，取绝对值，再将这16个绝对值相加，就得到了V的值
# V=16Σi (|Ip-Ii|)
# 最后比较毗邻候选角点的V值，把V值较小的候选角点去掉
# FAST算法的思想与我们对角点的直观认识非常接近，化繁为简
# 但是在噪声较高时不够稳定，这需要设置合适的阈值
